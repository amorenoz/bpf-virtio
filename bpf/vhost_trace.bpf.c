#include "vmlinux.h"
#include "vhost_trace.h"
#include <bpf/bpf_helpers.h>
#include <bpf/bpf_core_read.h>
#include <bpf/bpf_tracing.h>


/*FIXME: vmlinux.h generated by simply running 
 * bpftool btf dump file /sys/kernel/btf/vmlinux format c > vmlinux.h
 * on my 5.5.8-200.fc31.x86_64 did not include BPF_F* definitions
 *
enum {
	BPF_F_INDEX_MASK = 4294967295,
	BPF_F_CURRENT_CPU = 4294967295,
	BPF_F_CTXLEN_MASK = 0,
};
 */

struct {
	__uint(type, BPF_MAP_TYPE_PERF_EVENT_ARRAY);
	__uint(key_size, sizeof(u32));
	__uint(value_size, sizeof(u32));
} events SEC(".maps");


/*Unfortunately __builtin_memcmp is not being inlined*/
static __always_inline
bool is_vhost_file(char *fname)
{
	if (fname[0] == '/' &&
	    fname[1] == 'd' &&
	    fname[2] == 'e' &&
	    fname[3] == 'v' &&
	    fname[4] == '/' &&
	    fname[5] == 'v' &&
	    fname[6] == 'h' &&
	    fname[7] == 'o' &&
	    fname[8] == 's' &&
	    fname[9] == 't')
		return true;
	return false;
}

SEC("tracepoint/syscalls/sys_enter_openat")
int tracepoint__syscalls__sys_enter_openat(struct trace_event_raw_sys_enter* ctx)
{
	struct vhost_trace_event event = {};
	u64 id = bpf_get_current_pid_tgid();

	const char* fname = (const char *)ctx->args[1];
	bpf_probe_read_str(&event.fname, sizeof(event.fname), fname);
	if (!is_vhost_file(&event.fname[0])) {
		return 0;
	}

	event.ts = bpf_ktime_get_ns();
	event.pid = bpf_get_current_pid_tgid() >> 32;
	event.uid = bpf_get_current_uid_gid();
	event.etype = VHOST_TRACE_OPEN;

	bpf_perf_event_output(ctx, &events, BPF_F_CURRENT_CPU,
			      &event, sizeof(event));
	return 0;
}

SEC("tracepoint/syscalls/sys_enter_open")
int tracepoint__syscalls__sys_enter_open(struct trace_event_raw_sys_enter* ctx)
{
	struct vhost_trace_event event = {};
	u64 id = bpf_get_current_pid_tgid();
	/* use kernel terminology here for tgid/pid: */
	// u32 tgid = id >> 32;
	// u32 pid = id;

	const char* fname = (const char *)ctx->args[0];
	bpf_probe_read_str(&event.fname, sizeof(event.fname), fname);
	if (!is_vhost_file(&event.fname[0])) {
		return 0;
	}

	event.ts = bpf_ktime_get_ns();
	event.pid = bpf_get_current_pid_tgid() >> 32;
	event.uid = bpf_get_current_uid_gid();
	event.etype = VHOST_TRACE_OPEN;


	bpf_perf_event_output(ctx, &events, BPF_F_CURRENT_CPU,
			      &event, sizeof(event));
	return 0;
}

//SEC("kprobe/vhost_dev_ioctl")
//int BPF_KPROBE(kprobe__vhost_dev_ioctl, void *dev, unsigned int ioctl, void *argp)
//{
//	struct event event = {};
//	u64 id = bpf_get_current_pid_tgid();
//	event.pid = bpf_get_current_pid_tgid() >> 32;
//	event.uid = bpf_get_current_uid_gid();
//	event.etype = VHOST_MSG;
//	event.msg = ioctl;
//
//	bpf_perf_event_output(ctx, &events, BPF_F_CURRENT_CPU,
//			      &event, sizeof(event));
//}

char LICENSE[] SEC("license") = "GPL";
